// Everything in this file has been generated by Microsoft Copilot
// Only change made was a corrected import path for toString and top level test suite name
// Prompt used was "Generate test suite for this function. Use mocha chai"
// The file toString.js was given as additional context


// test/toString.spec.js
import { expect } from 'chai';
import toString from '../../src/toString.js';

describe('Ai generated test for toString()', () => {
    describe('strings', () => {
        it('returns the same string (early exit)', () => {
            expect(toString('hello')).to.equal('hello');
            expect(toString('')).to.equal('');
        });
    });

    describe('numbers', () => {
        it('converts positive and negative numbers', () => {
            expect(toString(123)).to.equal('123');
            expect(toString(-456)).to.equal('-456');
        });

        it('converts floats', () => {
            expect(toString(3.14159)).to.equal('3.14159');
        });

        it('preserves the sign of -0', () => {
            const minusZero = -0; // eslint-disable-line no-unsafe-negation
            expect(1 / minusZero).to.equal(-Infinity); // sanity check
            expect(toString(minusZero)).to.equal('-0');
        });

        it('converts Infinity and NaN', () => {
            expect(toString(Infinity)).to.equal('Infinity');
            expect(toString(-Infinity)).to.equal('-Infinity');
            expect(toString(NaN)).to.equal('NaN');
        });
    });

    describe('booleans', () => {
        it('converts true/false', () => {
            expect(toString(true)).to.equal('true');
            expect(toString(false)).to.equal('false');
        });
    });

    describe('nullish values (as documented)', () => {
        it('returns empty string for null', () => {
            expect(toString(null)).to.equal('');
        });

        it('returns empty string for undefined', () => {
            expect(toString(undefined)).to.equal('');
        });
    });

    describe('arrays', () => {
        it('flattens simple arrays via recursive conversion', () => {
            expect(toString([1, 2, 3])).to.equal('1,2,3');
            expect(toString(['a', 'b', 'c'])).to.equal('a,b,c');
        });

        it('handles nested arrays', () => {
            expect(toString([1, [2, 3], 4])).to.equal('1,2,3,4');
            expect(toString([[1], [2, [3]]])).to.equal('1,2,3');
        });

        it('keeps nullish elements as literal null/undefined in arrays (per current code)', () => {
            // In the array path, `other == null ? other : toString(other)` returns `null/undefined` elements as-is,
            // so the final string includes "null" or "undefined" literals.
            expect(toString([1, null, 3])).to.equal('1,null,3');
            expect(toString([undefined, 2])).to.equal('undefined,2');
        });
    });

    describe('symbols', () => {
        it('converts a primitive Symbol via Symbol.prototype.toString', () => {
            const s = Symbol('desc');
            expect(toString(s)).to.equal('Symbol(desc)');
        });

        it('converts a boxed Symbol object', () => {
            const boxed = Object(Symbol('boxed'));
            expect(toString(boxed)).to.equal('Symbol(boxed)');
        });
    });

    describe('BigInt', () => {
        it('converts BigInt to its decimal string', () => {
            expect(toString(1n)).to.equal('1');
            expect(toString(9007199254740993n)).to.equal('9007199254740993');
        });
    });

    describe('objects', () => {
        it('uses default object stringification', () => {
            expect(toString({ a: 1 })).to.equal('[object Object]');
        });

        it('respects custom toString methods', () => {
            const obj = {
                toString() {
                    return 'custom';
                },
            };
            expect(toString(obj)).to.equal('custom');
        });
    });

    describe('functions', () => {
        it('returns function source string', () => {
            function foo() { return 42; }
            const result = toString(foo);
            expect(result).to.be.a('string');
            expect(result).to.include('function foo');
        });
    });
});
