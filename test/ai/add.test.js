// Everything in this file has been generated by Microsoft Copilot
// Only change made was a corrected import path for add and top level test suite name
// Prompt used was "Generate test suite for this function. Use mocha chai"
// The file add.js was given as additional context


// test/add.spec.js
import { expect } from 'chai';
import add from '../../src/add.js';

describe('Ai-generated tests for add()', () => {
    describe('basic arithmetic', () => {
        it('adds two positive integers', () => {
            expect(add(6, 4)).to.equal(10);
        });

        it('adds a positive and a negative number', () => {
            expect(add(10, -3)).to.equal(7);
        });

        it('adds negatives', () => {
            expect(add(-5, -5)).to.equal(-10);
        });

        it('adds with zero', () => {
            expect(add(0, 5)).to.equal(5);
            expect(add(5, 0)).to.equal(5);
            expect(add(0, 0)).to.equal(0);
        });
    });

    describe('floating point numbers', () => {
        it('adds decimals (with tolerance for floating point precision)', () => {
            const result = add(0.1, 0.2);
            expect(result).to.be.closeTo(0.3, 1e-12);
        });

        it('adds multiple magnitudes of floats', () => {
            expect(add(1.2345, 6.789)).to.be.closeTo(8.0235, 1e-12);
        });
    });

    describe('missing and nullish arguments', () => {
        it('treats missing second argument as 0', () => {
            expect(add(6)).to.equal(6);
        });

        it('treats both missing arguments as 0', () => {
            // add() -> default + default
            expect(add()).to.equal(0);
        });

        it('treats null as 0 via numeric coercion', () => {
            expect(add(null, 5)).to.equal(5);
            expect(add(5, null)).to.equal(5);
            expect(add(null, null)).to.equal(0);
        });

        it('treats undefined like missing argument (defaults to 0)', () => {
            expect(add(undefined, 7)).to.equal(7);
            expect(add(7, undefined)).to.equal(7);
        });
    });

    describe('string numerics', () => {
        it('adds numeric strings', () => {
            expect(add('6', '4')).to.equal(10);
        });

        it('adds mixed string and number', () => {
            expect(add('8', 2)).to.equal(10);
            expect(add(2, '8')).to.equal(10);
        });
    });

    describe('invalid inputs', () => {
        it('returns NaN when input cannot be converted to number', () => {
            const r1 = add('foo', 1);
            const r2 = add(1, 'bar');
            const r3 = add('foo', 'bar');

            expect(Number.isNaN(r1)).to.equal(true);
            expect(Number.isNaN(r2)).to.equal(true);
            expect(Number.isNaN(r3)).to.equal(true);
        });
    });

    describe('large numbers', () => {
        it('adds large integers within safe range', () => {
            const a = Number.MAX_SAFE_INTEGER - 10; // 9007199254740981
            const b = 9;
            // still safe
            expect(add(a, b)).to.equal(Number.MAX_SAFE_INTEGER - 1);
        });

        it('demonstrates precision caveat beyond safe range', () => {
            // Not asserting exact equalityâ€”just ensuring it returns a number.
            const a = Number.MAX_SAFE_INTEGER;
            const b = 10;
            const result = add(a, b);
            expect(result).to.be.a('number');
            // If you *want* to assert behavior, you could check not safe:
            // expect(Number.isSafeInteger(result)).to.equal(false);
        });
    });
});
